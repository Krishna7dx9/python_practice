# ============================================================
# DSA — TIME OPTIMIZATION NOTES (INTERVIEW FIRST PRIORITY)
# ============================================================

# RULE 0
# Always optimize TIME first in interviews.
# Space optimization comes later or only if asked.

# ============================================================
# STEP 1: ALWAYS WRITE CURRENT COMPLEXITY
# ============================================================

# Before optimizing, always know:
# Time: ?
# Space: ?

# If you cannot state this, STOP.

# ============================================================
# STEP 2: TIME OPTIMIZATION RED FLAGS
# (These tell you WHERE time is being wasted)
# ============================================================

# RED FLAG 1: Nested loops
# --------------------------------
# for i in range(n):
#     for j in range(n):
#
# Meaning:
# Time = O(n^2)
#
# Action:
# Can this be reduced to ONE pass?


# RED FLAG 2: Searching inside a loop
# --------------------------------
# for x in arr:
#     if x in arr:   # or list
#
# Meaning:
# Repeated O(n) search → O(n^2)
#
# Action:
# Replace list with set or dict


# RED FLAG 3: Recomputing same values
# --------------------------------
# for i in range(n):
#     sum(arr[:i])
#
# Meaning:
# Same work done again and again
#
# Action:
# Use prefix sum / precomputation


# RED FLAG 4: Comparing every pair
# --------------------------------
# for i in range(n):
#     for j in range(i+1, n):
#
# Meaning:
# Pairwise comparison → slow
#
# Action:
# Sorting OR hashing OR two pointers


# RED FLAG 5: Recursion with n → n-1
# --------------------------------
# f(n-1)
#
# Meaning:
# Linear work, stack overhead
#
# Action:
# Convert to iteration (loop)


# RED FLAG 6: Slicing inside loops or recursion
# --------------------------------
# arr[1:], arr[:i]
#
# Meaning:
# Hidden O(n) time per call
#
# Action:
# Use index pointers instead


# ============================================================
# STEP 3: MAP RED FLAGS TO OPTIMIZATION TOOLS
# ============================================================

# If problem involves SEARCHING
# ------------------------------
# Tool: set / dict
# Time improvement: O(n^2) → O(n)


# If problem involves COUNTING / FREQUENCY
# ----------------------------------------
# Tool: dict
# Time improvement: repeated scan → single pass


# If problem involves SORTED DATA
# -------------------------------
# Tool: Two pointers
# Time improvement: nested loops → O(n)


# If problem involves SUBARRAY / RANGE
# -----------------------------------
# Tool: Sliding window / Prefix sum
# Time improvement: repeated sum → O(n)


# If problem involves RECURSION ONLY
# ---------------------------------
# Tool: Iteration
# Time same, but stack overhead removed


# ============================================================
# STEP 4: STANDARD TIME OPTIMIZATION REPLACEMENTS
# ============================================================

# Replace:
# - list lookup     → set / dict lookup
# - nested loops    → hashing / two pointers
# - recomputation   → prefix sum
# - recursion       → loop
# - slicing         → index variable


# ============================================================
# STEP 5: INTERVIEW JUSTIFICATION TEMPLATE
# ============================================================

# Say this clearly:

# "I identified the bottleneck as repeated scanning
# and optimized it using a hash-based lookup,
# reducing time complexity."

# OR

# "This solution optimizes time from O(n^2) to O(n)
# by using additional space."

# ============================================================
# ONE-LINE RULE (MEMORIZE)
# ============================================================

# Time optimization = remove repeated work
# using known data structures or patterns.
